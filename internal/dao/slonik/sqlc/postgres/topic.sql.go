// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: topic.sql

package dbr

import (
	"context"
)

const decrTagsById = `-- name: DecrTagsById :exec
UPDATE p_tag
SET quote_num = quote_num-1,
	modified_on=$1
WHERE id IN (
	SELECT id
	FROM p_tag
	WHERE id = ANY($2::BIGINT[]) AND is_del = false AND quote_num >= 1
)
`

type DecrTagsByIdParams struct {
	ModifiedOn int64
	Ids        []int64
}

func (q *Queries) DecrTagsById(ctx context.Context, arg *DecrTagsByIdParams) error {
	_, err := q.db.Exec(ctx, decrTagsById, arg.ModifiedOn, arg.Ids)
	return err
}

const hotTags = `-- name: HotTags :many
SELECT  t.id, t.tag, t.quote_num, u.id user_id, u.nickname, u.username, u.status, u.avatar, u.is_admin 
FROM p_tag t JOIN p_user u ON t.user_id = u.id
WHERE  t.is_del = false AND t.quote_num > 0
ORDER BY quote_num DESC
OFFSET $1 LIMIT $2
`

type HotTagsParams struct {
	Offset int32
	Limit  int32
}

type HotTagsRow struct {
	ID       int64
	Tag      string
	QuoteNum int64
	UserID   int64
	Nickname string
	Username string
	Status   int16
	Avatar   string
	IsAdmin  bool
}

func (q *Queries) HotTags(ctx context.Context, arg *HotTagsParams) ([]*HotTagsRow, error) {
	rows, err := q.db.Query(ctx, hotTags, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*HotTagsRow
	for rows.Next() {
		var i HotTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.QuoteNum,
			&i.UserID,
			&i.Nickname,
			&i.Username,
			&i.Status,
			&i.Avatar,
			&i.IsAdmin,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrTags = `-- name: IncrTags :many
UPDATE p_tag
SET quote_num = quote_num+1, 
	modified_on = $1,
	id_del = false
WHERE id IN (
	SELECT id
	FROM p_tag
	WHERE tag = ANY($2::VARCHAR[])
)
RETURNING id, user_id, tag, quote_num
`

type IncrTagsParams struct {
	ModifiedOn int64
	Tags       []string
}

type IncrTagsRow struct {
	ID       int64
	UserID   int64
	Tag      string
	QuoteNum int64
}

func (q *Queries) IncrTags(ctx context.Context, arg *IncrTagsParams) ([]*IncrTagsRow, error) {
	rows, err := q.db.Query(ctx, incrTags, arg.ModifiedOn, arg.Tags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*IncrTagsRow
	for rows.Next() {
		var i IncrTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tag,
			&i.QuoteNum,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertTags = `-- name: InsertTags :one
INSERT INTO p_tag (user_id, tag, created_on, modified_on, quote_num)
VALUES ($1, $2, $3, $3, 1)
RETURNING id
`

type InsertTagsParams struct {
	UserID    int64
	Tag       string
	CreatedOn int64
}

func (q *Queries) InsertTags(ctx context.Context, arg *InsertTagsParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertTags, arg.UserID, arg.Tag, arg.CreatedOn)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const newestTags = `-- name: NewestTags :many
SELECT t.id, t.tag, t.quote_num, u.id user_id, u.nickname, u.username, u.status, u.avatar, u.is_admin 
FROM p_tag t JOIN p_user u ON t.user_id = u.id
WHERE t.is_del = false AND t.quote_num > 0 
ORDER BY t.id DESC
OFFSET $1 LIMIT $2
`

type NewestTagsParams struct {
	Offset int32
	Limit  int32
}

type NewestTagsRow struct {
	ID       int64
	Tag      string
	QuoteNum int64
	UserID   int64
	Nickname string
	Username string
	Status   int16
	Avatar   string
	IsAdmin  bool
}

func (q *Queries) NewestTags(ctx context.Context, arg *NewestTagsParams) ([]*NewestTagsRow, error) {
	rows, err := q.db.Query(ctx, newestTags, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*NewestTagsRow
	for rows.Next() {
		var i NewestTagsRow
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.QuoteNum,
			&i.UserID,
			&i.Nickname,
			&i.Username,
			&i.Status,
			&i.Avatar,
			&i.IsAdmin,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagsByKeywordA = `-- name: TagsByKeywordA :many
SELECT id, user_id, tag, quote_num
FROM p_tag
WHERE is_del AND quote_num > 0
ORDER BY quote_num DESC
OFFSET 0 LIMIT 6
`

type TagsByKeywordARow struct {
	ID       int64
	UserID   int64
	Tag      string
	QuoteNum int64
}

func (q *Queries) TagsByKeywordA(ctx context.Context) ([]*TagsByKeywordARow, error) {
	rows, err := q.db.Query(ctx, tagsByKeywordA)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TagsByKeywordARow
	for rows.Next() {
		var i TagsByKeywordARow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tag,
			&i.QuoteNum,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const tagsByKeywordB = `-- name: TagsByKeywordB :many
SELECT id, user_id, tag, quote_num
FROM p_tag
WHERE is_del = false AND tag LIKE $1
ORDER BY quote_num DESC
OFFSET 0 LIMIT 6
`

type TagsByKeywordBRow struct {
	ID       int64
	UserID   int64
	Tag      string
	QuoteNum int64
}

func (q *Queries) TagsByKeywordB(ctx context.Context, tag string) ([]*TagsByKeywordBRow, error) {
	rows, err := q.db.Query(ctx, tagsByKeywordB, tag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*TagsByKeywordBRow
	for rows.Next() {
		var i TagsByKeywordBRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Tag,
			&i.QuoteNum,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
